# ot.py
# program takes in as command line arguments the desired number of syllables per word
#  and the names of desired constraints; constraints defined in separate file 'constraints.py'

import sys
from collections import Counter
import itertools
from constraints import *

#function generates all possible n-syllabled words with one iamb or one trochee
def makecandidates(n):
# words are lists containing n-2 0's (unstressed syllables) and 1 foot
# the foot is a tuple, either iambic -- (0,1) -- or trochaic -- (1,0)
  cands_as_lists = []
  for i in range(n-1):
#   build a word: first some 0's, then the foot, then some more 0's
    iamb_word,trochee_word = [0]*i,[0]*i
    iamb_word.append((0,1))
    trochee_word.append((1,0))
    iamb_word.extend([0]*(n-2-i))
    trochee_word.extend([0]*(n-2-i))
    cands_as_lists.append(iamb_word)
    cands_as_lists.append(trochee_word)
  return cands_as_lists

#this is EVAL  
def evaluate(candidates,constraints):
# rankedvmap is a dictionary mapping each candidate to a list of violations
# each entry in a candidate's violation list is the number of violations that
#   that candidate receives from one of the constraints; the first number is the
#   number of violations from the highest-ranked constraint, the second the second-
#   highest constraint, etc.
  rankedvmap = {}
  for word in candidates:      
    rankedvmap[word] = [f(word) for f in constraints]
# now the candidates get filtered in the usual way, until there is (hopefully) 
#   only one candidate left
  while len(rankedvmap.keys()) > 1:
#   l is a column in a tableau: it contains the number of violations
#     each candidate receives from the (current) highest-ranked constraint
    l = []
    for ranking in rankedvmap.values():
      l.append(ranking[0])
#   loserlist collects all of the candidates who do worse than the best candidate
#     on the current highest-ranked constraint
    loserlist = [x for x in rankedvmap.keys() if rankedvmap[x][0] > min(l)]
#   throw out the losers, move on to the next constraint and repeat
    for x in loserlist:
      del rankedvmap[x]
    for x in rankedvmap.keys():       
      del rankedvmap[x][0]
# some optional print statements to make sure EVAL isn't lying
#   print [con.__name__ for con in constraints],
#   print rankedvmap.keys()
  return rankedvmap.keys()[0]

def main():
# constraint_set is a list of constraints passed in from the command line
  constraint_set = [eval(x) for x in sys.argv[2:]]
# cands is just the list of candidates generated by makecandidates(n)
#   but each candidate is coerced into a tuple, so that it will be hashable
  cands = [tuple(x) for x in makecandidates(int(sys.argv[1]))]
# con_perms is a list of all possible permutations of the constraint set  
  con_perms = list(itertools.permutations(constraint_set))
# results is a list of the winning candidates (one for each permutation) 
  results = map(lambda x:evaluate(cands,x), con_perms)
# dist is a dictionary mapping each (winning) candidate to the number of
#   permutations that favored it
  dist = {r: Counter(results)[r]/float(len(results)) for r in Counter(results)}
# these are print statements  
  print "\nConstraints:"
  for m in sys.argv[2:]:
    print m+',',
  
  print "\n\nCandidates:"
  for c in cands:
    print c
  
  print "\nDistribution of Winners:"
  for r in dist:
    print str(r) + ': ' + str(round(dist[r],2))
  print "\n"

main()
